#include <iostream>
#include "Aggregation.h"
#include "Composition.h"


//Агрегация. В объектно-ориентированном программировании под агрегированием (или как его
//еще называли ранее - делегированием) подразумевают методику создания нового
//класса из уже существующих классов путём их включения.Об агрегировании также
//часто говорят как об «отношении принадлежности» по принципу «у машины есть
//корпус, колёса и двигатель».

//Композиция(агрегирование по значению) — более строгий вариант агрегирования,
//когда включаемый объект может существовать только как часть контейнера.Если
//контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.



int main() {

    std::cout << "Agregation" << std::endl;
    Motor m(150);
    Car c(m);
    std::cout << c.getPower() << std::endl;
    std::cout << "---------------------------\n";   

    std::cout << "Composition" << std::endl;
    Engine engine(120);
    Motorbike bike(120);
    std::cout << bike.getPower() << std::endl;
    std::cout << "---------------------------\n";   

    return 0;
}



//Композиция: объект A управляет временем жизни объекта B
//Плюсы:
//Композиция позволяет скрыть отношение использования объектов от глаз клиента.
//Делает API использования класса более простым и позволяет перейти от использования одного класса, к другому.
//Минусы:
//Отношение достаточно жесткое, поскольку один объект должен уметь создавать другой : он должен знать конкретный тип и иметь доступ к функции создания.
//Композиция не позволяет использовать интерфейсы(без привлечения фабрик) и требует, чтобы класс имел доступ к конструктору другого класса.

//Агрегация: объект А получает ссылку на объект B
//Плюсы:
//Более слабая связанность между объектом и его клиентом.Теперь мы можем использовать интерфейсы и одному объекту не нужно знать, как именно создавать другой объект.
//Большая гибкость.Вытекает из первого пункта.
//Минусы:
//Выставление наружу деталей реализации. Поскольку клиент класса должен предоставить зависимость в момент создания объекта, то сам факт этого отношения становится известен клиенту..
//Из первого пункта вытекает увеличение сложности в работе клиентов, а также большая "жесткость" решения в долгосрочной перспективе.

//Композиция проще с точки зрения клиентов класса, но налагает определенные ограничения: "целое" должно уметь создавать "составную часть".
//Агрегация гибче, но налагает другие ограничения: теперь "целое" не скрывает о существовании "составной части", а значит и не сможет заменить ее на другую "составную часть" в будущем.